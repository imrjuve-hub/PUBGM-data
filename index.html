<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PUBG Match Viewer - Multi Match</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/dayjs@1.11.10/dayjs.min.js"></script>
  <script src="https://unpkg.com/dayjs@1.11.10/plugin/duration.js"></script>
  <script>dayjs.extend(window.dayjs_plugin_duration)</script>
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .card { @apply bg-white/90 backdrop-blur rounded-2xl shadow-lg p-6 border border-slate-100; }
    .title { @apply text-slate-900 font-semibold; }
    .sub { @apply text-slate-500 text-sm; }
    .chip { @apply inline-flex items-center gap-1 rounded-full px-2 py-1 text-xs bg-slate-100 text-slate-600; }
    .btn { @apply inline-flex items-center justify-center rounded-xl px-4 py-2 font-medium bg-slate-900 text-white hover:bg-slate-700 transition; }
    .btn-ghost { @apply inline-flex items-center justify-center rounded-xl px-4 py-2 font-medium bg-white text-slate-700 border hover:bg-slate-50; }
    .th { @apply text-left text-xs font-semibold text-slate-500 uppercase tracking-wider; }
    .td { @apply whitespace-nowrap text-slate-800; }
    .dropzone { @apply relative flex flex-col items-center justify-center gap-3 rounded-2xl border-2 border-dashed border-slate-300 p-8 hover:border-slate-400 transition bg-white; }
    .dropzone.dragover { @apply border-indigo-400 bg-indigo-50; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-b from-slate-50 to-slate-100 text-slate-900">
  <div id="root"></div>

  <script type="text/babel">
    const { useMemo, useState, useEffect, useRef } = React;

    const fmtNum = (n) => {
      if (n === null || n === undefined || Number.isNaN(n)) return "";
      const v = typeof n === 'string' ? Number(n) : n;
      return isFinite(v) ? v.toLocaleString() : '';
    };
    const fmtMeters = (m) => m ? `${Math.round(m)} m` : '';
    const fmtTime = (seconds) => {
      if (seconds === null || seconds === undefined || Number.isNaN(seconds)) return '';
      const s = Number(seconds);
      if (!isFinite(s)) return '';
      const dur = dayjs.duration({ seconds: Math.max(0, Math.floor(s)) });
      const h = dur.hours();
      const mm = String(dur.minutes()).padStart(2, '0');
      const ss = String(dur.seconds()).padStart(2, '0');
      return h > 0 ? `${h}:${mm}:${ss}` : `${mm}:${ss}`;
    };
    const coalesce = (obj, key, d=0) => obj?.[key] == null ? d : obj[key];

    const readFileAsText = (file) => new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsText(file, 'utf-8');
    });

    const extractPlayers = (json) => {
      if (!json) return [];
      if (Array.isArray(json.playerInfoList)) return json.playerInfoList;
      if (Array.isArray(json.players)) return json.players;
      for (const k of Object.keys(json)) {
        const v = json[k];
        if (Array.isArray(v) && v.length && typeof v[0] === 'object' && 'playerName' in v[0]) return v;
      }
      return [];
    };

    function perMatchTeams(players) {
      const map = new Map();
      players.forEach(p => {
        const teamId = p.teamId ?? p.teamID ?? p.TeamId ?? p.team_id ?? 0;
        const teamName = p.teamName || p.TeamName || `Team ${teamId}`;
        const rank = p.rank ?? p.Rank ?? null;
        const rec = map.get(teamId) || { teamId, teamName, Rank: rank, Kills: 0, Damage: 0, Survival: [], Longest: 0, Players: 0 };
        rec.Rank = rec.Rank == null ? rank : Math.min(rec.Rank, rank ?? rec.Rank);
        rec.Kills += Number(coalesce(p, 'killNum', 0));
        rec.Damage += Number(coalesce(p, 'damage', 0));
        rec.Survival.push(Number(coalesce(p, 'survivalTime', 0)));
        rec.Longest = Math.max(rec.Longest, Number(coalesce(p, 'maxKillDistance', 0)));
        rec.Players += 1;
        map.set(teamId, rec);
      });
      let rows = Array.from(map.values()).map(r => ({...r, AvgSurvival: r.Survival.length ? _.mean(r.Survival) : 0 }));
      const hasRank = rows.some(r => r.Rank != null && r.Rank !== -1);
      rows = hasRank ? _.orderBy(rows, ['Rank', 'Kills', 'Damage'], ['asc', 'desc', 'desc'])
                     : _.orderBy(rows, ['Kills', 'Damage'], ['desc', 'desc']).map((r,i)=>({...r, Computed_Rank: i+1}));
      return rows;
    }

    function aggregateTeams(matches) {
      const map = new Map();
      matches.forEach(m => {
        const per = perMatchTeams(m.players);
        per.forEach(t => {
          const id = t.teamId;
          const rec = map.get(id) || {
            teamId: id, teamName: t.teamName, Matches: 0, Wins: 0,
            Total_Kills: 0, Total_Damage: 0, Survival_Secs: [], Longest_Kill_Distance: 0, Ranks: []
          };
          rec.teamName = t.teamName || rec.teamName;
          rec.Matches += 1;
          rec.Wins += (t.Rank === 1 ? 1 : 0);
          rec.Total_Kills += t.Kills;
          rec.Total_Damage += t.Damage;
          rec.Survival_Secs.push(...t.Survival);
          rec.Longest_Kill_Distance = Math.max(rec.Longest_Kill_Distance, t.Longest);
          if (t.Rank != null) rec.Ranks.push(t.Rank);
          map.set(id, rec);
        });
      });
      let rows = Array.from(map.values()).map(r => ({
        ...r,
        Avg_Survival_Time: r.Survival_Secs.length ? _.mean(r.Survival_Secs) : 0,
        Avg_Rank: r.Ranks.length ? _.mean(r.Ranks) : null,
      }));
      const hasAnyRank = rows.some(r => r.Avg_Rank != null);
      rows = hasAnyRank
        ? _.orderBy(rows, ['Wins', 'Avg_Rank', 'Total_Kills', 'Total_Damage'], ['desc', 'asc', 'desc', 'desc'])
        : _.orderBy(rows, ['Wins', 'Total_Kills', 'Total_Damage'], ['desc', 'desc', 'desc']);
      return rows;
    }

    function aggregatePlayersByTeam(matches) {
      const teamMap = new Map();
      const playerKey = (p) => p.uId || p.playerOpenId || p.playerKey || `${p.playerName}#${p.teamId}`;
      matches.forEach(m => {
        m.players.forEach(p => {
          const tid = p.teamId ?? p.teamID ?? p.TeamId ?? 0;
          const tname = p.teamName || `Team ${tid}`;
          if (!teamMap.has(tid)) teamMap.set(tid, { teamId: tid, teamName: tname, players: new Map() });
          const tm = teamMap.get(tid);
          const pk = playerKey(p);
          const rec = tm.players.get(pk) || {
            playerName: p.playerName || 'Unknown', matches: 0, kills: 0, damage: 0, headshots: 0,
            assists: 0, knocks: 0, survival: [], longest: 0
          };
          rec.matches += 1;
          rec.kills += Number(coalesce(p, 'killNum', 0));
          rec.damage += Number(coalesce(p, 'damage', 0));
          rec.headshots += Number(coalesce(p, 'headShotNum', 0));
          rec.assists += Number(coalesce(p, 'assists', 0));
          rec.knocks += Number(coalesce(p, 'knockouts', 0));
          rec.survival.push(Number(coalesce(p, 'survivalTime', 0)));
          rec.longest = Math.max(rec.longest, Number(coalesce(p, 'maxKillDistance', 0)));
          tm.players.set(pk, rec);
        });
      });
      const result = new Map();
      teamMap.forEach((v, tid) => {
        const arr = Array.from(v.players.values()).map(p => ({ ...p, avgSurvival: p.survival.length ? _.mean(p.survival) : 0 }));
        const sorted = _.orderBy(arr, ['kills', 'damage'], ['desc', 'desc']);
        result.set(tid, { teamId: tid, teamName: v.teamName, players: sorted });
      });
      return result;
    }

    function MultiDrop({ onData }) {
      const ref = useRef(null);
      const onFiles = async (fileList) => {
        try {
          const files = Array.from(fileList || []);
          const parsed = [];
          for (const f of files) {
            const text = await readFileAsText(f);
            const json = JSON.parse(text);
            parsed.push({ name: f.name, players: extractPlayers(json) });
          }
          onData(parsed);
        } catch (e) {
          alert('Could not read one of the JSON files');
          console.error(e);
        }
      };
      useEffect(() => {
        const el = ref.current; if (!el) return;
        const prevent = e => { e.preventDefault(); e.stopPropagation(); };
        const onDrag = e => { prevent(e); el.classList.add('dragover'); };
        const onLeave = e => { prevent(e); el.classList.remove('dragover'); };
        const onDrop = e => { prevent(e); el.classList.remove('dragover'); onFiles(e.dataTransfer.files); };
        el.addEventListener('dragenter', onDrag);
        el.addEventListener('dragover', onDrag);
        el.addEventListener('dragleave', onLeave);
        el.addEventListener('drop', onDrop);
        return () => {
          el.removeEventListener('dragenter', onDrag);
          el.removeEventListener('dragover', onDrag);
          el.removeEventListener('dragleave', onLeave);
          el.removeEventListener('drop', onDrop);
        };
      }, []);
      return (
        <div className="card">
          <div ref={ref} className="dropzone">
            <div className="text-xl font-semibold">Upload multiple match JSON files</div>
            <div className="sub">Drag and drop files here or choose from your device</div>
            <label className="btn mt-2 cursor-pointer">
              <input type="file" accept="application/json,.json" multiple className="hidden" onChange={(e) => onFiles(e.target.files)} />
              Choose files
            </label>
          </div>
        </div>
      );
    }

    function PlayersTable({ team }) {
      if (!team) return <div className="sub">No player data</div>;
      const rows = team.players || [];
      return (
        <div>
          <div className="mb-2 font-semibold">Players - {team.teamName}</div>
          <div className="overflow-x-auto">
            <table className="min-w-full text-sm">
              <thead>
                <tr className="border-b bg-white">
                  <th className="th">Player</th>
                  <th className="th text-center">Matches</th>
                  <th className="th text-center">Kills</th>
                  <th className="th text-center">Damage</th>
                  <th className="th text-center">HS</th>
                  <th className="th text-center">Assists</th>
                  <th className="th text-center">Knocks</th>
                  <th className="th text-center">Avg Survival</th>
                  <th className="th text-center">Longest Kill</th>
                </tr>
              </thead>
              <tbody>
                {rows.map((p, idx) => (
                  <tr key={idx} className="border-b">
                    <td className="td">{p.playerName}</td>
                    <td className="td text-center">{fmtNum(p.matches)}</td>
                    <td className="td text-center">{fmtNum(p.kills)}</td>
                    <td className="td text-center">{fmtNum(p.damage)}</td>
                    <td className="td text-center">{fmtNum(p.headshots)}</td>
                    <td className="td text-center">{fmtNum(p.assists)}</td>
                    <td className="td text-center">{fmtNum(p.knocks)}</td>
                    <td className="td text-center">{fmtTime(p.avgSurvival)}</td>
                    <td className="td text-center">{fmtMeters(p.longest)}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      );
    }

    function TeamAggregateTable({ rows, playerMap }) {
      const [open, setOpen] = useState(new Set());
      const [sort, setSort] = useState({ key: 'Wins', dir: 'desc' });
      const display = useMemo(() => {
        const copy = [...rows];
        const { key } = sort; const dir = sort.dir === 'asc' ? 1 : -1;
        copy.sort((a,b) => {
          const va = a[key] ?? 0; const vb = b[key] ?? 0;
          if (va < vb) return -1 * dir; if (va > vb) return 1 * dir; return 0;
        });
        return copy;
      }, [rows, sort]);
      const toggle = (tid) => {
        const s = new Set(open); s.has(tid) ? s.delete(tid) : s.add(tid); setOpen(s);
      };
      const header = (label, key, center=false) => (
        <th className={f`th ${center ? 'text-center' : ''}`}>
          <button className="hover:underline" onClick={() => setSort({ key, dir: sort.dir === 'asc' ? 'desc' : 'asc' })}>{label}</button>
        </th>
      );
      return (
        <div className="card overflow-hidden">
          <div className="flex items-center justify-between mb-4">
            <h3 className="title text-xl">Overall Team Leaderboard</h3>
            <span className="chip">Click headers to sort - click a row to expand players</span>
          </div>
          <div className="overflow-x-auto">
            <table className="min-w-full">
              <thead>
                <tr className="border-b bg-slate-50">
                  {header('Team', 'teamName')}
                  {header('Matches', 'Matches', true)}
                  {header('Wins', 'Wins', true)}
                  {header('Avg Rank', 'Avg_Rank', true)}
                  {header('Total Kills', 'Total_Kills', true)}
                  {header('Total Damage', 'Total_Damage', true)}
                  {header('Avg Survival', 'Avg_Survival_Time', true)}
                  {header('Longest Kill', 'Longest_Kill_Distance', true)}
                </tr>
              </thead>
              <tbody>
                {display.map((r) => (
                  <React.Fragment key={r.teamId}>
                    <tr className="border-b hover:bg-slate-50 cursor-pointer" onClick={() => toggle(r.teamId)}>
                      <td className="td font-semibold">{r.teamName}</td>
                      <td className="td text-center">{fmtNum(r.Matches)}</td>
                      <td className="td text-center">{fmtNum(r.Wins)}</td>
                      <td className="td text-center">{r.Avg_Rank != null ? r.Avg_Rank.toFixed(2) : '-'}</td>
                      <td className="td text-center">{fmtNum(r.Total_Kills)}</td>
                      <td className="td text-center">{fmtNum(r.Total_Damage)}</td>
                      <td className="td text-center">{fmtTime(r.Avg_Survival_Time)}</td>
                      <td className="td text-center">{fmtMeters(r.Longest_Kill_Distance)}</td>
                    </tr>
                    {open.has(r.teamId) && (
                      <tr className="bg-slate-50/60">
                        <td colSpan="8" className="p-4">
                          <PlayersTable team={playerMap.get(r.teamId)} />
                        </td>
                      </tr>
                    )}
                  </React.Fragment>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      );
    }

    function MatchesList({ matches }) {
      if (!matches.length) return null;
      return (
        <div className="card">
          <h3 className="title text-xl mb-4">Matches</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {matches.map((m, idx) => {
              const teams = perMatchTeams(m.players).slice(0,3);
              return (
                <div key={idx} className="rounded-xl border p-4 bg-white">
                  <div className="font-semibold mb-2">{m.name || `Match ${idx+1}`}</div>
                  <ol className="list-decimal ml-6 text-slate-700">
                    {teams.map((t,i)=>(
                      <li key={i}>{t.teamName} - Kills {fmtNum(t.Kills)} - Damage {fmtNum(t.Damage)}</li>
                    ))}
                  </ol>
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    function App() {
      const [matches, setMatches] = useState([]);

      const addFiles = async (fileList) => {
        const files = Array.from(fileList || []);
        const parsed = [];
        for (const f of files) {
          try {
            const text = await readFileAsText(f);
            const json = JSON.parse(text);
            parsed.push({ name: f.name, players: extractPlayers(json) });
          } catch (e) {
            console.error('Bad file', f.name, e);
          }
        }
        setMatches(prev => [...prev, ...parsed]);
      };

      const totals = useMemo(() => {
        const teamIds = new Set(); const playerKeys = new Set();
        let kills = 0, damage = 0;
        matches.forEach(m => {
          m.players.forEach(p => {
            teamIds.add(p.teamId ?? p.teamID ?? p.TeamId ?? 0);
            const pk = p.uId || p.playerOpenId || p.playerKey || `${p.playerName}#${p.teamId}`;
            playerKeys.add(pk);
            kills += Number(coalesce(p,'killNum',0));
            damage += Number(coalesce(p,'damage',0));
          });
        });
        return { matches: matches.length, teams: teamIds.size, players: playerKeys.size, kills, damage };
      }, [matches]);

      const teamRows = useMemo(() => aggregateTeams(matches), [matches]);
      const playerMap = useMemo(() => aggregatePlayersByTeam(matches), [matches]);

      return (
        <div className="max-w-6xl mx-auto px-4 py-10">
          <header className="mb-8">
            <h1 className="text-3xl md:text-4xl font-extrabold tracking-tight">PUBG Match Viewer</h1>
            <p className="text-slate-600 mt-2">Upload multiple match JSON files. See overall team leaderboard and player stats per team.</p>
          </header>

          {!matches.length ? (
            <MultiDrop onData={(parsed) => setMatches(parsed)} />
          ) : (
            <>
              <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
                <div className="card"><div className="sub">Matches</div><div className="text-2xl font-bold">{fmtNum(totals.matches)}</div></div>
                <div className="card"><div className="sub">Teams</div><div className="text-2xl font-bold">{fmtNum(totals.teams)}</div></div>
                <div className="card"><div className="sub">Players</div><div className="text-2xl font-bold">{fmtNum(totals.players)}</div></div>
                <div className="card"><div className="sub">Total Kills</div><div className="text-2xl font-bold">{fmtNum(totals.kills)}</div></div>
                <div className="card"><div className="sub">Total Damage</div><div className="text-2xl font-bold">{fmtNum(totals.damage)}</div></div>
              </div>

              <div className="mb-6 flex flex-wrap items-center justify-between gap-2">
                <div className="flex items-center gap-2">
                  <span className="chip">Loaded files</span>
                  <span className="sub">{matches.map(m=>m.name).join(', ')}</span>
                </div>
                <div className="flex gap-2">
                  <label className="btn-ghost cursor-pointer">
                    <input type="file" accept="application/json,.json" multiple className="hidden" onChange={(e)=> addFiles(e.target.files)} />
                    Add more
                  </label>
                  <button className="btn-ghost" onClick={()=>setMatches([])}>Reset</button>
                </div>
              </div>

              <div className="space-y-6">
                <TeamAggregateTable rows={teamRows} playerMap={playerMap} />
                <MatchesList matches={matches} />
              </div>
            </>
          )}

          <footer className="mt-14 text-center text-slate-500 text-sm">Static - deploy to Vercel as index.html</footer>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
